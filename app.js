// Generated by CoffeeScript 1.10.0
(function() {
  var _, app, checkWhenRules, colors, config, e, error1, express, getHTMLAndCheckWhenRules, i, len, logger, monitorRule, nodemailer, notify, notifyError, notifySuccess, port, ref, request, rule, sendEmail, sendSlack, slackRequest, whenRuleMap, winston;

  colors = require('colors');

  winston = require('winston');

  request = require('request');

  _ = require('underscore');

  nodemailer = require('nodemailer');

  request = require('request');

  try {
    config = require('./config');
  } catch (error1) {
    e = error1;
    logger.error("Problem reading config.js: ", e.stack || e);
    config = {};
  }

  logger = new winston.Logger({
    transports: [
      new winston.transports.Console({
        level: config.logLevel || 'info',
        colorize: true,
        timestamp: true
      })
    ],
    exitOnError: true
  });

  sendEmail = function(options) {
    var emailServerOpt, mailOptions, transport;
    options.subject = options.rule.url + " is ready!";
    emailServerOpt = config.emailServer;
    transport = nodemailer.createTransport(emailServerOpt.type, emailServerOpt.parameters);
    mailOptions = _.extend({}, {
      from: config.fromEmail || "Node Notifier âœ” <noreply@nodenotifier.tv>",
      to: config.toEmail
    }, options);
    return transport.sendMail(mailOptions, function(error, response) {
      if (error) {
        logger.warn(error);
      } else {
        logger.info("Message sent: " + response.message);
      }
      return transport.close();
    });
  };

  slackRequest = function(url, data, done) {
    if (!url) {
      logger.error('No URL');
      return false;
    }
    if (!_.isFunction(done)) {
      done = function() {
        return {};
      };
    }
    return request.post(url, {
      form: {
        payload: JSON.stringify(data)
      }
    }, function(err, response) {
      if (err) {
        logger.info("slackRequest : Error sending message");
        return done(err);
      }
      if (response.body !== 'ok') {
        logger.info("slackRequest : Error sending message");
        return done(new Error(response.body));
      }
      logger.info("slackRequest : Message sent", data);
      return done();
    });
  };

  sendSlack = function(options) {
    var data, hooks;
    if (!config.slackWebhook) {
      return;
    }
    options = _.extend({}, options, config.slackOpts);
    data = {};
    logger.info("sendSlack : Sending message", data);
    hooks = _.isArray(config.slackWebhook) ? config.slackWebhook : [config.slackWebhook];
    return hooks.map((function(url) {
      var _data, parseFn;
      _data = _.extend({}, options.extra, data);
      parseFn = options.rule.fn || options.parseFn || function(ops) {
        ops.text = (options.prefix ? options.prefix + " - " : "") + (options.text + "");
        return ops;
      };
      _data = parseFn(_data);
      return slackRequest(url, _data);
    }));
  };

  notify = function(options) {
    if (config.toEmail) {
      sendEmail(options);
    }
    if (config.slackWebhook) {
      return sendSlack(options);
    }
  };

  notifySuccess = function(rule, body) {
    return notify({
      rule: rule,
      text: "Your condition was matched at " + rule.url
    });
  };

  notifyError = function(rule, error, response, body) {
    return notify({
      rule: rule,
      text: "Error on " + rule.url + "\nError: " + error + "\nResponse code: " + (response && response.statusCode) + "\nContent: " + body
    });
  };

  whenRuleMap = [
    {
      type: 'exist',
      f: function(whenRule, body) {
        return body.indexOf(whenRule) >= 0;
      }
    }, {
      type: 'notExist',
      f: function(whenRule, body) {
        return body.indexOf(whenRule) < 0;
      }
    }, {
      type: 'regExpMatch',
      f: function(whenRule, body) {
        return body.match(whenRule);
      }
    }
  ];

  checkWhenRules = function(rule, body) {
    var found, i, j, len, len1, w, whenRule, wr;
    w = rule.when;
    if (!w) {
      logger.error("you need a when rule");
      return;
    }
    if (_.isArray(w)) {
      for (i = 0, len = w.length; i < len; i++) {
        whenRule = w[i];
        found = false;
        for (j = 0, len1 = whenRuleMap.length; j < len1; j++) {
          wr = whenRuleMap[j];
          if (whenRule[wr.type]) {
            found = true;
            logger.debug(wr.type, whenRule[wr.type]);
            if (wr.f(whenRule[wr.type], body)) {
              notifySuccess(rule, body);
              return;
            } else {
              logger.debug(wr.type + " not matched");
            }
          }
        }
        if (!found) {
          logger.warn("Unknown 'when' rule for url", rule.url, " The only known rules are in whenRuleMap");
        }
      }
    } else if (_.isFunction(w)) {
      logger.debug("Checking function result");
      if (w(body, rule)) {
        notifySuccess(rule, body);
      } else {
        return logger.debug("function returned falsy");
      }
    }
  };

  getHTMLAndCheckWhenRules = function(rule) {
    var options, url;
    url = rule.url;
    options = {
      'method': 'GET',
      'uri': url
    };
    logger.debug("Retriving url:", url);
    return request(options, function(error, response, body) {
      if (!error && response.statusCode === 200) {
        return checkWhenRules(rule, body);
      } else if (error) {
        logger.warn(("error: " + error).red);
        if (config.notifyErrors) {
          return notifyError(rule, error, response, body);
        }
      } else {
        logger.warn(("Response code: " + response.statusCode + "\nContent: " + body).red);
        if (config.notifyErrors) {
          return notifyError(rule, error, response, body);
        }
      }
    });
  };

  monitorRule = function(rule) {
    return (function(rule) {
      var often;
      often = rule.frequency || 60 * 60 * 1000;
      logger.info("Every ", often / 1000, " sec, I will monitor rule", rule);
      rule.timerID = setInterval(function() {
        return getHTMLAndCheckWhenRules(rule);
      }, often);
      return getHTMLAndCheckWhenRules(rule);
    })(rule);
  };

  if (!config.rules || config.rules.length === 0) {
    logger.error("No rules to track".error);
    process.exit(-1);
  }

  ref = config.rules;
  for (i = 0, len = ref.length; i < len; i++) {
    rule = ref[i];
    if (!rule.url) {
      logger.error("Missing URL".error, rule);
      process.exit(-1);
    }
    monitorRule(rule);
  }

  express = require('express');

  app = express();

  app.use(express.logger());

  app.use(express.bodyParser());

  app.use("/static", express["static"](__dirname + '/styles'));

  app.set('views', __dirname + '/views');

  app.engine('.html', require('ejs').__express);

  app.set('view engine', 'ejs');

  app.get('/status', function(req, res) {
    return res.json({
      status: "ok"
    });
  });

  port = process.env.PORT || config.port || 3000;

  app.listen(port, function() {
    return logger.log("Listening on " + port);
  });

}).call(this);

//# sourceMappingURL=app.js.map
